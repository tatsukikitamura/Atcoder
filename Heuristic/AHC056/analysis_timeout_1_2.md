# 1_2.cpp の2000ms超過ケース分析

## 超過したテストケース一覧

| テストケース | N | K | T | 実行時間 | スコア | 密度 |
|------------|---|---|---|---------|--------|------|
| 0074.txt | 20 | 197 | 4343 | **2167.9ms** | 441 | 0.4925 |
| 0107.txt | 20 | 179 | 7580 | **2208.0ms** | 430 | 0.4475 |
| 0255.txt | 18 | 146 | 3975 | **2382.3ms** | 347 | 0.4506 |

## 共通の特徴

### 1. ターゲット密度が高い
- **0074.txt**: 密度=0.4925 (197/400) - ほぼ半分のマスがターゲット
- **0107.txt**: 密度=0.4475 (179/400) - 約45%のマスがターゲット
- **0255.txt**: 密度=0.4506 (146/324) - 約45%のマスがターゲット

**すべてのケースで密度が0.45以上**。通常のケースは密度0.1-0.3程度。

### 2. 区間数（K-1）が非常に大きい
- **0074.txt**: 196区間
- **0107.txt**: 178区間
- **0255.txt**: 145区間

ビームサーチは各区間ごとに実行されるため、**区間数が多いほど計算量が増大**。

### 3. パラメータ設定による計算量増大

#### 1_2.cppのパラメータ設定（密度ベース）

**N >= 19の場合:**
- density >= 0.75: BEAM_WIDTH=6, N_PATHS_PER_STATE=3
- density >= 0.625: BEAM_WIDTH=8, N_PATHS_PER_STATE=4
- density >= 0.5: BEAM_WIDTH=10, N_PATHS_PER_STATE=5
- **else (0.45-0.5)**: BEAM_WIDTH=12, N_PATHS_PER_STATE=6

**N < 19の場合:**
- density >= 0.875: BEAM_WIDTH=8, N_PATHS_PER_STATE=4
- density >= 0.75: BEAM_WIDTH=10, N_PATHS_PER_STATE=5
- density >= 0.625: BEAM_WIDTH=11, N_PATHS_PER_STATE=5
- density >= 0.5: BEAM_WIDTH=14, N_PATHS_PER_STATE=7

#### 実際のパラメータ値

- **0074.txt** (N=20, density=0.4925): BEAM_WIDTH=12, N_PATHS_PER_STATE=6
- **0107.txt** (N=20, density=0.4475): BEAM_WIDTH=12, N_PATHS_PER_STATE=6
- **0255.txt** (N=18, density=0.4506): BEAM_WIDTH=14, N_PATHS_PER_STATE=7

### 4. 計算量の分析

ビームサーチの計算量は以下の式で表される：

```
総計算量 = Σ(k=0 to K-2) [BEAM_WIDTH × N_PATHS_PER_STATE × Dijkstra計算量]
```

#### 0074.txtの場合:
- 区間数: 196
- ビーム幅: 12
- パス数: 6
- **各区間あたりの状態数: 12 × 6 = 72**
- **総状態数: 196 × 72 = 14,112**

#### 0107.txtの場合:
- 区間数: 178
- ビーム幅: 12
- パス数: 6
- **各区間あたりの状態数: 12 × 6 = 72**
- **総状態数: 178 × 72 = 12,816**

#### 0255.txtの場合:
- 区間数: 145
- ビーム幅: 14
- パス数: 7
- **各区間あたりの状態数: 14 × 7 = 98**
- **総状態数: 145 × 98 = 14,210**

### 5. パレート最適ダイクストラの計算量

`find_path_dijkstra_beam`関数は、各状態に対して：
- **ステップ数ごとに状態を保持** (`map<Pos, map<int, long long>>`)
- **ドミネーションチェック**（既存状態との比較）
- **優先度キューによる探索**

**問題点:**
1. **step_limitが大きい**: 密度が高いと、既存パスとの重複が少なく、step_limitが大きくなる傾向がある
2. **探索空間の増大**: 各状態で複数のステップ数を持つため、探索空間が指数的に増大
3. **ドミネーションチェックのコスト**: 各状態に対して既存状態との比較が必要

### 6. 壁の配置パターン

#### 0074.txt
- 大部分が0（壁なし）
- 一部に1の壁が存在（31行目、40行目）
- **通路が広い** → 探索空間が大きい

#### 0107.txt
- 複雑な壁の配置
- 多くの通路が存在
- **探索の選択肢が多い**

#### 0255.txt
- 比較的シンプルな壁の配置
- しかし密度が高いため、探索空間が大きい

## 改善提案

### 1. 密度が高い場合のパラメータ削減
密度0.45-0.5の範囲でも、さらにパラメータを削減する：

```cpp
if (density >= 0.45 && density < 0.5) {
    BEAM_WIDTH = 8;  // 12 → 8
    N_PATHS_PER_STATE = 4;  // 6 → 4
}
```

### 2. タイムアウト処理の追加
各セグメント処理の前に時間チェックを追加し、時間がかかりすぎる場合は早期終了：

```cpp
auto current_time = chrono::high_resolution_clock::now();
auto elapsed_ms = chrono::duration_cast<chrono::milliseconds>(current_time - start_time).count();
if (elapsed_ms >= 1800) {  // 1800msで打ち切り
    break;
}
```

### 3. step_limitの制限
密度が高い場合、step_limitをより厳しく制限：

```cpp
if (density >= 0.45) {
    step_limit = min(step_limit, X_k * 2);  // 最短距離の2倍まで
}
```

### 4. パレート最適ダイクストラの最適化
- 探索空間の上限を設定
- ドミネーションチェックの最適化
- 早期終了条件の追加

