# 2000ms超過ケースの分析

## 超過したテストケース一覧

| テストケース | N | K | T | 1_3実行時間 | 1_1実行時間 | 1_3スコア | 1_1スコア |
|------------|---|---|---|------------|------------|----------|----------|
| 0019.txt | 20 | 302 | 18748 | **2837.2ms** | 638ms | 638 | 638 |
| 0042.txt | 19 | 273 | 10154 | **2500.7ms** | 569ms | 568 | 569 |
| 0068.txt | 20 | 371 | 6289 | **3336.6ms** | **2120.0ms** | 748 | 748 |
| 0071.txt | 20 | 352 | 13458 | **2609.1ms** | 713ms | 713 | 713 |
| 0097.txt | 20 | 213 | 9868 | **2132.4ms** | 483ms | 482 | 483 |

## 共通の特徴

### 1. K（ターゲット数）が非常に大きい
- 0019.txt: K=302
- 0042.txt: K=273
- 0068.txt: K=371（最大）
- 0071.txt: K=352
- 0097.txt: K=213

**すべてのケースでKが200以上**。通常のケースはK=50-100程度。

### 2. 1_3が1_1より遅い理由

#### パラメータの違い
- **1_3**: `BEAM_WIDTH=16`, `N_PATHS_PER_STATE=8`
- **1_1**: `BEAM_WIDTH=10`, `N_PATHS_PER_STATE=5`

#### 計算量への影響

ビームサーチの計算量は以下の式で表される：
```
総計算量 = (K-1) × BEAM_WIDTH × N_PATHS_PER_STATE × パレート最適ダイクストラの計算量
```

1_3の場合：
- 区間数: K-1 = 301 (0019.txtの場合)
- ビーム幅: 16
- パス数: 8
- **各区間あたりの状態数: 16 × 8 = 128**

1_1の場合：
- 区間数: K-1 = 301 (0019.txtの場合)
- ビーム幅: 10
- パス数: 5
- **各区間あたりの状態数: 10 × 5 = 50**

**1_3は1_1の約2.56倍の状態数を探索している**

### 3. パレート最適ダイクストラの計算量

`find_path_dijkstra_beam`関数は、各状態に対して：
- ステップ数ごとに状態を保持（`map<Pos, map<int, long long>>`）
- ドミネーションチェック（既存状態との比較）
- 優先度キューによる探索

**Kが大きいと、各区間のstep_limitも大きくなる可能性があり、探索空間が指数的に増大する**

特に0068.txtでは：
- K=371（最大）
- T=6289（比較的小さい）
- **step_limitが大きくなり、探索空間が爆発的に増大**

## なぜ超過してしまったのか

### 根本原因

1. **Kが大きいケースでの計算量爆発**
   - ビームサーチの区間数 = K-1
   - K=371の場合、301個の区間を処理
   - 各区間で16×8=128個の状態を探索
   - **総状態数: 301 × 128 = 38,528個以上**

2. **パレート最適ダイクストラの計算量**
   - 各状態で`step_limit`までのステップを探索
   - `step_limit`が大きいと、探索空間が指数的に増大
   - ドミネーションチェックの計算量も増加

3. **1_3のパラメータ設定**
   - BEAM_WIDTH=16, N_PATHS_PER_STATE=8は、Kが小さい場合には有効
   - **Kが大きい場合には計算量が爆発的に増大**

### 0068.txtで両方が超過した理由

- K=371（最大）
- T=6289（比較的小さい）
- **step_limitが大きくなり、探索空間が爆発的に増大**
- 1_1でも2120msと超過（ただし1_3よりは速い）

## 改善案

### 1. 動的なパラメータ調整
```cpp
// Kが大きい場合はパラメータを小さくする
if (K > 200) {
    BEAM_WIDTH = 8;
    N_PATHS_PER_STATE = 4;
} else if (K > 100) {
    BEAM_WIDTH = 12;
    N_PATHS_PER_STATE = 6;
} else {
    BEAM_WIDTH = 16;
    N_PATHS_PER_STATE = 8;
}
```

### 2. step_limitの上限設定
```cpp
// step_limitに上限を設ける
step_limit = min(step_limit, X_k + 50); // 最大50ステップの余裕
```

### 3. 時間制限の追加
```cpp
// パレート最適ダイクストラ内で時間チェック
auto current_time = chrono::high_resolution_clock::now();
if (duration_cast<chrono::milliseconds>(current_time - start_time).count() > 1800) {
    // 早期終了
    break;
}
```

### 4. 早期終了の実装
- 一定時間経過後、ビームサーチを途中で打ち切る
- 既存の最良解を返す

## 結論

**2000ms超過の主な原因は、Kが大きいケースでの計算量爆発**。

1_3のパラメータ（BEAM_WIDTH=16, N_PATHS_PER_STATE=8）は、Kが小さい場合には有効だが、Kが大きい場合には計算量が爆発的に増大する。

**改善策として、Kの大きさに応じてパラメータを動的に調整するか、時間制限を追加する必要がある。**



